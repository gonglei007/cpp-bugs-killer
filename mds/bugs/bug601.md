<h2 align="center">运算符重载返回引用</h2>

## 找Bug

这段代码有什么问题？

```cpp
class Complex
{
public:
    double real, imag;
    Complex();
};

Complex& operator+( Complex& a, Complex& b)
{
    Complex *p = new Complex;
    p->real = a.real + b.real;
    p->imag = a.imag + b.imag;
    return *p;
}
```

### 说明

**问题分析：**

这是一个典型的运算符重载设计错误。二元运算符 `+` 返回引用是不合适的，因为：

1. **内存泄漏**：函数内部使用 `new` 分配了内存，但返回引用后，调用者无法知道需要释放这块内存
2. **语义错误**：`+` 运算符应该返回一个新对象，而不是引用
3. **生命周期问题**：返回局部对象的引用会导致悬空引用

**正确的写法：**

```cpp
// 方法1：返回对象（推荐）
Complex operator+( const Complex& a, const Complex& b)
{
    Complex result;
    result.real = a.real + b.real;
    result.imag = a.imag + b.imag;
    return result;  // 返回对象，编译器会进行优化（RVO/NRVO）
}

// 方法2：如果必须使用new，返回指针（不推荐）
Complex* operator+( const Complex& a, const Complex& b)
{
    Complex *p = new Complex;
    p->real = a.real + b.real;
    p->imag = a.imag + b.imag;
    return p;  // 调用者需要delete
}
```

**要点：**
- 运算符重载原则：二元运算符通常应该返回对象，而不是引用
- 内存管理：避免在运算符重载中使用 `new`，让调用者管理内存
- 返回值优化：现代编译器支持RVO（返回值优化），返回对象通常不会有性能问题
- 引用返回：只有 `=`、`[]`、`()` 等运算符适合返回引用

---
* [示例代码](../../source/bug601/source/main.cpp)

## 拓展阅读
* [C++ Operator Overloading Best Practices](https://en.cppreference.com/w/cpp/language/operators)

