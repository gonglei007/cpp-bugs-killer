<h2 align="center">内存泄漏</h2>

## 找Bug

这段代码有什么问题？

```cpp
void ProcessData()
{
    int* data = new int[1000];
    // ... 使用data进行一些操作
    if (someCondition) {
        return;  // Bug: 提前返回，没有释放内存
    }
    // ... 更多操作
    delete[] data;
}
```

### 说明

**问题分析：**

当 `someCondition` 为真时，函数提前返回，导致 `delete[] data` 永远不会执行，造成内存泄漏。

**内存泄漏的危害：**
- 程序运行时间越长，占用的内存越多
- 最终可能导致系统内存耗尽
- 在长时间运行的程序中尤其危险

**正确的写法：**

**方法1：使用智能指针（C++11+，推荐）**
```cpp
#include <memory>

void ProcessData()
{
    std::unique_ptr<int[]> data(new int[1000]);
    // ... 使用data进行一些操作
    if (someCondition) {
        return;  // 自动释放内存
    }
    // ... 更多操作
    // 自动释放内存，无需手动delete
}
```

**方法2：使用RAII原则**
```cpp
class DataHolder {
    int* data;
public:
    DataHolder(size_t size) : data(new int[size]) {}
    ~DataHolder() { delete[] data; }
    int* get() { return data; }
};

void ProcessData()
{
    DataHolder holder(1000);
    int* data = holder.get();
    // ... 使用data进行一些操作
    if (someCondition) {
        return;  // holder析构时自动释放内存
    }
    // ... 更多操作
}
```

**方法3：确保所有路径都释放内存**
```cpp
void ProcessData()
{
    int* data = new int[1000];
    // ... 使用data进行一些操作
    if (someCondition) {
        delete[] data;  // 提前返回前释放
        return;
    }
    // ... 更多操作
    delete[] data;
}
```

**要点：**
- RAII原则：资源获取即初始化，利用析构函数自动释放资源
- 智能指针：`std::unique_ptr`、`std::shared_ptr` 等可以自动管理内存
- 异常安全：使用智能指针可以保证即使发生异常也能正确释放内存
- 最佳实践：现代C++应尽量避免使用 `new/delete`，优先使用智能指针和容器

---
* [示例代码](../../source/bug502/source/main.cpp)

## 拓展阅读
* [RAII](https://en.cppreference.com/w/cpp/language/raii)
* [Smart Pointers](https://en.cppreference.com/w/cpp/memory)

